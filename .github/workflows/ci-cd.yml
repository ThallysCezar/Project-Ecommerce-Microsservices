# ==============================================================================
# CI/CD Pipeline - E-commerce Microservices
# ==============================================================================
# Este workflow automatiza:
# 1. Build e testes de todos os microservices
# 2. Build e push de imagens Docker para Docker Hub
# 3. (Opcional) Deploy no Kubernetes
#
# Triggers:
# - Push na branch main
# - Pull requests para main
# ==============================================================================

name: CI/CD Pipeline

# ==============================================================================
# TRIGGER: Quando o pipeline deve executar?
# ==============================================================================
on:
  # Executa quando h√° push na branch main
  push:
    branches: [ main ]
  
  # Executa quando h√° pull request para main
  pull_request:
    branches: [ main ]
  
  # Permite executar manualmente via interface do GitHub
  workflow_dispatch:

# ==============================================================================
# VARI√ÅVEIS GLOBAIS
# ==============================================================================
env:
  # Nome de usu√°rio do Docker Hub (ser√° usado para nomear as imagens)
  DOCKER_USERNAME: thallyscezar
  
  # Vers√£o do Java para build (deve ser a mesma do projeto)
  JAVA_VERSION: '17'
  
  # Vers√£o do Maven
  MAVEN_VERSION: '3.9.x'

# ==============================================================================
# JOBS: Conjunto de tarefas que o pipeline executa
# ==============================================================================
jobs:
  
  # ==========================================================================
  # JOB 0: INSTALL COMMON-DTOS
  # ==========================================================================
  # Objetivo: Instalar o m√≥dulo compartilhado common-dtos no reposit√≥rio Maven local
  # Por qu√™? Outros microservices dependem dele (ms-usuarios, ms-produtos, etc)
  # Este job DEVE rodar antes de todos os outros
  # ==========================================================================
  install-common-dtos:
    name: üì¶ Install Common DTOs
    runs-on: ubuntu-latest
    
    steps:
      # ----------------------------------------------------------------------
      # STEP 1: Checkout do c√≥digo
      # ----------------------------------------------------------------------
      - name: üì• Checkout code
        uses: actions/checkout@v4
      
      # ----------------------------------------------------------------------
      # STEP 2: Configurar Java
      # ----------------------------------------------------------------------
      - name: ‚òï Set up JDK 17
        uses: actions/setup-java@v4
        with:
          java-version: ${{ env.JAVA_VERSION }}
          distribution: 'temurin'
          cache: maven
      
      # ----------------------------------------------------------------------
      # STEP 3: Instalar common-dtos no reposit√≥rio local
      # ----------------------------------------------------------------------
      # O qu√™ faz? Compila e instala common-dtos no reposit√≥rio Maven local
      # Por qu√™? Outros microservices precisam dessa depend√™ncia
      # mvn install = Compila + instala no ~/.m2/repository
      # ----------------------------------------------------------------------
      - name: üì¶ Install common-dtos
        run: |
          echo "Installing common-dtos to local Maven repository..."
          mvn -B -f common-dtos/pom.xml clean install -DskipTests
          echo "‚úÖ common-dtos installed successfully!"
      
      # ----------------------------------------------------------------------
      # STEP 4: Fazer upload do common-dtos instalado
      # ----------------------------------------------------------------------
      # O qu√™ faz? Salva o reposit√≥rio Maven local (~/.m2/repository)
      # Por qu√™? O pr√≥ximo job vai precisar dele
      # Cache entre jobs n√£o funciona, ent√£o fazemos upload/download manual
      # ----------------------------------------------------------------------
      - name: üì§ Upload Maven repository
        uses: actions/upload-artifact@v4
        with:
          name: maven-repository
          path: ~/.m2/repository
          retention-days: 1  # S√≥ precisa durante a execu√ß√£o do pipeline
  
  # ==========================================================================
  # JOB 1: BUILD & TEST
  # ==========================================================================
  # Objetivo: Compilar c√≥digo e executar todos os testes
  # Por qu√™? Garantir que o c√≥digo est√° funcionando antes de fazer deploy
  # needs: [install-common-dtos] = S√≥ executa depois do Job 0
  # ==========================================================================
  build-and-test:
    name: üî® Build & Test Microservices
    
    # Ambiente onde o job vai rodar (m√°quina virtual Ubuntu da GitHub)
    runs-on: ubuntu-latest
    
    # Depende do install-common-dtos: S√≥ executa ap√≥s instala√ß√£o do common-dtos
    needs: [install-common-dtos]
    
    # Estrat√©gia de matriz: Roda o mesmo job para m√∫ltiplos microservices
    # Por qu√™? N√£o precisamos repetir c√≥digo para cada microservice
    strategy:
      # fail-fast: false = Se um microservice falhar, continua testando os outros
      fail-fast: false
      
      # Matrix: Lista de microservices para testar
      matrix:
        service:
          - server              # Eureka Server
          - api-gateway         # API Gateway
          - ms-database         # Database Microservice
          - ms-usuarios         # Users Microservice
          - ms-produtos         # Products Microservice
          - ms-pedidos          # Orders Microservice
          - ms-pagamentos       # Payments Microservice
    
    steps:
      # ----------------------------------------------------------------------
      # STEP 1: Checkout do c√≥digo
      # ----------------------------------------------------------------------
      # O qu√™ faz? Baixa o c√≥digo do reposit√≥rio para a m√°quina virtual
      # Por qu√™? O GitHub Actions precisa do c√≥digo para fazer build
      # ----------------------------------------------------------------------
      - name: üì• Checkout code
        uses: actions/checkout@v4
      
      # ----------------------------------------------------------------------
      # STEP 2: Baixar reposit√≥rio Maven com common-dtos
      # ----------------------------------------------------------------------
      # O qu√™ faz? Baixa o reposit√≥rio Maven local criado pelo Job 0
      # Por qu√™? Precisamos do common-dtos instalado para buildar os microservices
      # ----------------------------------------------------------------------
      - name: üì• Download Maven repository
        uses: actions/download-artifact@v4
        with:
          name: maven-repository
          path: ~/.m2/repository
      
      # ----------------------------------------------------------------------
      # STEP 3: Configurar Java
      # ----------------------------------------------------------------------
      # O qu√™ faz? Instala o JDK 17 na m√°quina virtual
      # Por qu√™? Precisamos do Java para compilar os microservices Spring Boot
      # distribution: temurin = Vers√£o open-source do JDK (Eclipse Temurin)
      # ----------------------------------------------------------------------
      - name: ‚òï Set up JDK 17
        uses: actions/setup-java@v4
        with:
          java-version: ${{ env.JAVA_VERSION }}
          distribution: 'temurin'
          
          # Cache do Maven: Armazena depend√™ncias baixadas
          # Por qu√™? Evita baixar as mesmas depend√™ncias toda vez (mais r√°pido)
          cache: maven
      
      # ----------------------------------------------------------------------
      # STEP 4: Build com Maven
      # ----------------------------------------------------------------------
      # O qu√™ faz? Compila o c√≥digo do microservice
      # Por qu√™? Verificar se o c√≥digo compila sem erros
      # Agora funciona: common-dtos j√° est√° instalado no reposit√≥rio local!
      # Flags:
      #   -B = Batch mode (n√£o mostra progresso, mais limpo nos logs)
      #   -f = File (caminho para o pom.xml do microservice)
      #   clean = Limpa builds anteriores
      #   package = Compila e empacota o .jar
      #   -DskipTests = Pula testes nesta etapa (vamos rodar separado)
      # ----------------------------------------------------------------------
      - name: üî® Build ${{ matrix.service }}
        run: |
          echo "Building ${{ matrix.service }}..."
          mvn -B -f ${{ matrix.service }}/pom.xml clean package -DskipTests
      
      # ----------------------------------------------------------------------
      # STEP 5: Rodar Testes
      # ----------------------------------------------------------------------
      # O qu√™ faz? Executa todos os testes unit√°rios e de integra√ß√£o
      # Por qu√™? Garantir que o c√≥digo funciona corretamente
      # test = Roda os testes do Maven
      # ----------------------------------------------------------------------
      - name: üß™ Run tests for ${{ matrix.service }}
        run: |
          echo "Running tests for ${{ matrix.service }}..."
          mvn -B -f ${{ matrix.service }}/pom.xml test
      
      # ----------------------------------------------------------------------
      # STEP 6: Fazer upload do artefato (JAR)
      # ----------------------------------------------------------------------
      # O qu√™ faz? Salva o arquivo .jar gerado pelo build
      # Por qu√™? Pode ser usado depois para deploy ou debug
      # Opcional: Voc√™ pode baixar este arquivo na aba "Actions" do GitHub
      # ----------------------------------------------------------------------
      - name: üì¶ Upload artifact
        uses: actions/upload-artifact@v4
        with:
          name: ${{ matrix.service }}-jar
          path: ${{ matrix.service }}/target/*.jar
          retention-days: 7  # Mant√©m o arquivo por 7 dias
  
  # ==========================================================================
  # JOB 2: BUILD & PUSH DOCKER IMAGES
  # ==========================================================================
  # Objetivo: Criar imagens Docker e enviar para Docker Hub
  # Por qu√™? Precisamos das imagens para fazer deploy no Kubernetes
  # needs: [build-and-test] = S√≥ executa se o Job 1 passar com sucesso
  # ==========================================================================
  docker-build-push:
    name: üê≥ Build & Push Docker Images
    runs-on: ubuntu-latest
    
    # S√≥ executa se os testes passarem
    needs: [build-and-test]
    
    # S√≥ executa para push na main (n√£o para pull requests)
    # Por qu√™? N√£o queremos fazer deploy de pull requests n√£o aprovados
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'
    
    # Matrix: Lista de microservices para criar imagens Docker
    strategy:
      fail-fast: false
      matrix:
        service:
          - name: server
            context: ./server
          - name: api-gateway
            context: ./api-gateway
          - name: ms-database
            context: ./ms-database
          - name: ms-usuarios
            context: ./ms-usuarios
          - name: ms-produtos
            context: ./ms-produtos
          - name: ms-pedidos
            context: ./ms-pedidos
          - name: ms-pagamentos
            context: ./ms-pagamentos
    
    steps:
      # ----------------------------------------------------------------------
      # STEP 1: Checkout do c√≥digo
      # ----------------------------------------------------------------------
      - name: üì• Checkout code
        uses: actions/checkout@v4
      
      # ----------------------------------------------------------------------
      # STEP 2: Configurar Docker Buildx
      # ----------------------------------------------------------------------
      # O qu√™ faz? Configura o Docker Buildx (vers√£o avan√ßada do docker build)
      # Por qu√™? Permite builds mais r√°pidos e multi-plataforma (ARM, x86)
      # ----------------------------------------------------------------------
      - name: üîß Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
      
      # ----------------------------------------------------------------------
      # STEP 3: Login no Docker Hub
      # ----------------------------------------------------------------------
      # O qu√™ faz? Faz login no Docker Hub usando credenciais seguras
      # Por qu√™? Precisamos estar logados para fazer push das imagens
      # 
      # IMPORTANTE: Voc√™ precisa configurar secrets no GitHub:
      # 1. V√° em: Settings ‚Üí Secrets and variables ‚Üí Actions
      # 2. Adicione dois secrets:
      #    - DOCKER_USERNAME: seu username do Docker Hub
      #    - DOCKER_PASSWORD: seu password ou token do Docker Hub
      # ----------------------------------------------------------------------
      - name: üîê Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_PASSWORD }}
      
      # ----------------------------------------------------------------------
      # STEP 4: Extrair metadados
      # ----------------------------------------------------------------------
      # O qu√™ faz? Gera tags e labels para a imagem Docker
      # Por qu√™? Padroniza as tags (latest, sha-abc123, etc)
      # 
      # Tags geradas:
      # - latest: √öltima vers√£o
      # - sha-abc123: Hash do commit (para rastreabilidade)
      # ----------------------------------------------------------------------
      - name: üè∑Ô∏è Extract metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.DOCKER_USERNAME }}/ecommerce-${{ matrix.service.name }}
          tags: |
            type=raw,value=latest
            type=sha,prefix=sha-
      
      # ----------------------------------------------------------------------
      # STEP 5: Build e Push da imagem Docker
      # ----------------------------------------------------------------------
      # O qu√™ faz? Constr√≥i a imagem Docker e envia para Docker Hub
      # Por qu√™? Esta imagem ser√° usada no Kubernetes
      # 
      # context: Diret√≥rio onde est√° o Dockerfile
      # push: true = Envia a imagem para Docker Hub ap√≥s build
      # cache: Usa cache para acelerar builds futuros
      # ----------------------------------------------------------------------
      - name: üê≥ Build and push ${{ matrix.service.name }}
        uses: docker/build-push-action@v5
        with:
          context: ${{ matrix.service.context }}
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          
          # Cache layers para acelerar pr√≥ximos builds
          cache-from: type=gha
          cache-to: type=gha,mode=max
  
  # ==========================================================================
  # JOB 3: DEPLOY TO KUBERNETES (OPCIONAL)
  # ==========================================================================
  # Objetivo: Fazer deploy autom√°tico no Kubernetes
  # Por qu√™? Automatizar o deploy ap√≥s passar nos testes
  # 
  # NOTA: Este job est√° comentado porque deploy local (K3d) n√£o √© comum em CI/CD
  # Para produ√ß√£o, voc√™ configuraria deploy em EKS, AKS ou GKE
  # ==========================================================================
  # deploy-kubernetes:
  #   name: ‚ò∏Ô∏è Deploy to Kubernetes
  #   runs-on: ubuntu-latest
  #   needs: [docker-build-push]
  #   
  #   steps:
  #     - name: üì• Checkout code
  #       uses: actions/checkout@v4
  #     
  #     # Configurar kubectl com suas credenciais de cluster
  #     # Para cloud providers (EKS, AKS, GKE), voc√™ usaria actions espec√≠ficos
  #     - name: ‚öôÔ∏è Configure kubectl
  #       run: |
  #         # Configurar acesso ao cluster Kubernetes
  #         # Este passo varia dependendo de onde seu cluster est√°
  #         echo "Configure kubectl here"
  #     
  #     # Aplicar manifests do Kubernetes
  #     - name: üöÄ Deploy to Kubernetes
  #       run: |
  #         kubectl apply -f k8s/namespace.yaml
  #         kubectl apply -f k8s/configmaps/
  #         kubectl apply -f k8s/secrets/
  #         kubectl apply -f k8s/infrastructure/
  #         kubectl apply -f k8s/discovery/
  #         kubectl apply -f k8s/microservices/
  #         kubectl apply -f k8s/gateway/
  #     
  #     # Verificar se deploy foi bem-sucedido
  #     - name: ‚úÖ Verify deployment
  #       run: |
  #         kubectl wait --for=condition=ready pod --all -n ecommerce --timeout=300s
  #         kubectl get pods -n ecommerce

  # ==========================================================================
  # JOB 4: NOTIFICA√á√ÉO DE SUCESSO
  # ==========================================================================
  # Objetivo: Notificar que o pipeline completou com sucesso
  # Por qu√™? Feedback visual de que tudo funcionou
  # ==========================================================================
  notify-success:
    name: üì¢ Notify Success
    runs-on: ubuntu-latest
    needs: [docker-build-push]
    
    # S√≥ executa se todos os jobs anteriores passarem
    if: success()
    
    steps:
      - name: üéâ Pipeline completed successfully
        run: |
          echo "‚úÖ All microservices built, tested, and pushed to Docker Hub!"
          echo "üê≥ Docker images available at: https://hub.docker.com/u/${{ env.DOCKER_USERNAME }}"
          echo "üì¶ Tagged as: latest and sha-${{ github.sha }}"
